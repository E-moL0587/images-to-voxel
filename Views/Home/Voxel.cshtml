<div>
  <canvas id="mainCanvas"></canvas>
</div>

<div>
  <button onclick="showScene('voxel')">Voxel</button>
  <button onclick="showScene('mesh')">Mesh</button>
  <button onclick="showScene('smooth')">Smooth</button>
</div>

<script>
  const mainCanvas = document.querySelector('#mainCanvas');
  const renderer = new THREE.WebGLRenderer({ canvas: mainCanvas });
  const width = mainCanvas.clientWidth;
  const height = mainCanvas.clientHeight;
  renderer.setSize(width, height, false);

  const camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);
  camera.position.set(0, 0, 40);
  const controls = new THREE.OrbitControls(camera, renderer.domElement);

  const scenes = {
    voxel: new THREE.Scene(),
    mesh: new THREE.Scene(),
    smooth: new THREE.Scene()
  };

  function isSurfaceVoxel(x, y, z, data) {
    const directions = [
      [1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]
    ];
    for (let [dx, dy, dz] of directions) {
      if (!data.some(([nx, ny, nz]) => nx === x + dx && ny === y + dy && nz === z + dz)) {
        return true;
      }
    }
    return false;
  }

  function getSurfaceVoxels(data) {
    return data.filter(([x, y, z]) => isSurfaceVoxel(x, y, z, data));
  }

  function initScene(scene, data) {
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 7.5).normalize();
    scene.add(light);

    const boundingBox = new THREE.Box3();
    data.forEach(([x, y, z]) => boundingBox.expandByPoint(new THREE.Vector3(x, y, z)));
    const center = new THREE.Vector3();
    boundingBox.getCenter(center);

    if (scene === scenes.voxel) {
      const surfaceData = getSurfaceVoxels(data);
      surfaceData.forEach(([x, y, z]) => {
        const voxelMesh = new THREE.Mesh(
          new THREE.BoxGeometry(1, 1, 1),
          new THREE.MeshPhongMaterial({ color: 0xff00ff })
        );
        voxelMesh.position.set(-(x - center.x), -(y - center.y), -(z - center.z));
        scene.add(voxelMesh);
      });
    } else {
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      data.forEach(point => {
        vertices.push(-(point[0] - center.x), -(point[1] - center.y), -(point[2] - center.z));
      });
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.computeVertexNormals();
      const material = new THREE.MeshPhongMaterial({ color: 0xff00ff, side: THREE.DoubleSide });
      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);
    }
  }

  const voxelData = @Html.Raw(ViewData["VoxelData"]);
  const meshData = @Html.Raw(ViewData["MeshData"]);
  const smoothData = @Html.Raw(ViewData["SmoothData"]);

  initScene(scenes.voxel, voxelData);
  initScene(scenes.mesh, meshData);
  initScene(scenes.smooth, smoothData);

  let currentScene = scenes.voxel;
  let nextSceneName = 'voxel';
  const transitionDuration = 1000;
  let transitionStartTime = null;
  let initialSceneData = [];
  let targetSceneData = [];

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(currentScene, camera);
  }

  function animateTransition(timestamp) {
    if (!transitionStartTime) {
      transitionStartTime = timestamp;
      initialSceneData = getCurrentSceneData();
      targetSceneData = getSceneDataByName(nextSceneName);
      if (nextSceneName === 'voxel') {
        targetSceneData = getSurfaceVoxels(targetSceneData);
      }
      adjustDataLength(initialSceneData, targetSceneData);
    }

    const elapsed = timestamp - transitionStartTime;
    const progress = Math.min(elapsed / transitionDuration, 1);

    const interpolatedData = initialSceneData.map((point, i) => {
      const targetPoint = targetSceneData[i];
      return [
        point[0] + (targetPoint[0] - point[0]) * progress,
        point[1] + (targetPoint[1] - point[1]) * progress,
        point[2] + (targetPoint[2] - point[2]) * progress
      ];
    });

    currentScene.clear();
    const pointsMaterial = new THREE.PointsMaterial({ color: 0xff00ff, size: 0.5 });
    const pointsGeometry = new THREE.BufferGeometry();
    const pointsVertices = [];
    const boundingBox = new THREE.Box3();
    interpolatedData.forEach(([x, y, z]) => boundingBox.expandByPoint(new THREE.Vector3(x, y, z)));
    const center = new THREE.Vector3();
    boundingBox.getCenter(center);
    interpolatedData.forEach(point => {
      pointsVertices.push(-(point[0] - center.x), -(point[1] - center.y), -(point[2] - center.z));
    });
    pointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(pointsVertices, 3));
    const points = new THREE.Points(pointsGeometry, pointsMaterial);
    currentScene.add(points);

    if (progress < 1) {
      requestAnimationFrame(animateTransition);
    } else {
      transitionStartTime = null;
      currentScene = scenes[nextSceneName];
      initScenes();
    }
  }

  function adjustDataLength(sourceData, targetData) {
    const sourceLength = sourceData.length;
    const targetLength = targetData.length;

    if (sourceLength < targetLength) {
      const additionalPoints = targetLength - sourceLength;
      for (let i = 0; i < additionalPoints; i++) {
        sourceData.push(sourceData[i % sourceLength]);
      }
    } else if (sourceLength > targetLength) {
      const additionalPoints = sourceLength - targetLength;
      for (let i = 0; i < additionalPoints; i++) {
        targetData.push(targetData[i % targetLength]);
      }
    }
  }

  function showScene(sceneName) {
    nextSceneName = sceneName;
    requestAnimationFrame(animateTransition);
  }

  function initScenes() {
    scenes.voxel.clear();
    scenes.mesh.clear();
    scenes.smooth.clear();
    initScene(scenes.voxel, voxelData);
    initScene(scenes.mesh, meshData);
    initScene(scenes.smooth, smoothData);
  }

  function getCurrentSceneData() {
    if (currentScene === scenes.voxel) return getSurfaceVoxels(voxelData);
    if (currentScene === scenes.mesh) return meshData;
    if (currentScene === scenes.smooth) return smoothData;
    return [];
  }

  function getSceneDataByName(sceneName) {
    if (sceneName === 'voxel') return getSurfaceVoxels(voxelData);
    if (sceneName === 'mesh') return meshData;
    if (sceneName === 'smooth') return smoothData;
    return [];
  }

  animate();
</script>
