<div>
  <canvas id="mainCanvas"></canvas>
</div>

<div>
  <button onclick="showScene('voxel')">Voxel</button>
  <button onclick="showScene('mesh')">Mesh</button>
  <button onclick="showScene('smooth')">Smooth</button>
  <button onclick="togglePoints()">Toggle Points</button>
</div>

<script>
  const mainCanvas = document.querySelector('#mainCanvas');
  const renderer = new THREE.WebGLRenderer({ canvas: mainCanvas });
  const width = mainCanvas.clientWidth;
  const height = mainCanvas.clientHeight;
  renderer.setSize(width, height, false);

  const camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);
  camera.position.set(0, 0, 40);
  const controls = new THREE.OrbitControls(camera, renderer.domElement);

  const scenes = {
    voxel: new THREE.Scene(),
    mesh: new THREE.Scene(),
    smooth: new THREE.Scene()
  };

  function initScene(scene, data) {
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 7.5).normalize();
    scene.add(light);

    const boundingBox = new THREE.Box3();
    data.forEach(([x, y, z]) => boundingBox.expandByPoint(new THREE.Vector3(x, y, z)));
    const center = new THREE.Vector3();
    boundingBox.getCenter(center);

    if (scene === scenes.voxel) {
      data.forEach(([x, y, z]) => {
        const voxelMesh = new THREE.Mesh(
          new THREE.BoxGeometry(1, 1, 1),
          new THREE.MeshPhongMaterial({ color: 0xff00ff })
        );
        voxelMesh.position.set(-(x - center.x), -(y - center.y), -(z - center.z));
        scene.add(voxelMesh);
      });
    } else {
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      data.forEach(point => {
        vertices.push(-(point[0] - center.x), -(point[1] - center.y), -(point[2] - center.z));
      });
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.computeVertexNormals();
      const material = new THREE.MeshPhongMaterial({ color: 0xff00ff, side: THREE.DoubleSide });
      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);
    }
  }

  const voxelData = @Html.Raw(ViewData["VoxelData"]);
  const meshData = @Html.Raw(ViewData["MeshData"]);
  const smoothData = @Html.Raw(ViewData["SmoothData"]);

  initScene(scenes.voxel, voxelData);
  initScene(scenes.mesh, meshData);
  initScene(scenes.smooth, smoothData);

  let currentScene = scenes.voxel;
  let isPointMode = false;

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(currentScene, camera);
  }

  function showScene(sceneName) {
    currentScene = scenes[sceneName];
    if (isPointMode) {
      showPointsOnly();
    }
  }

  function togglePoints() {
    isPointMode = !isPointMode;
    if (isPointMode) {
      showPointsOnly();
    } else {
      initScenes();
    }
  }

  function initScenes() {
    scenes.voxel.clear();
    scenes.mesh.clear();
    scenes.smooth.clear();
    initScene(scenes.voxel, voxelData);
    initScene(scenes.mesh, meshData);
    initScene(scenes.smooth, smoothData);
  }

  function showPointsOnly() {
    currentScene.clear();
    const pointsMaterial = new THREE.PointsMaterial({ color: 0xff00ff, size: 0.5 });
    const pointsGeometry = new THREE.BufferGeometry();
    const pointsVertices = [];
    const data = getCurrentSceneData();
    const boundingBox = new THREE.Box3();
    data.forEach(([x, y, z]) => boundingBox.expandByPoint(new THREE.Vector3(x, y, z)));
    const center = new THREE.Vector3();
    boundingBox.getCenter(center);
    data.forEach(point => {
      pointsVertices.push(-(point[0] - center.x), -(point[1] - center.y), -(point[2] - center.z));
    });
    pointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(pointsVertices, 3));
    const points = new THREE.Points(pointsGeometry, pointsMaterial);
    currentScene.add(points);
  }

  function getCurrentSceneData() {
    if (currentScene === scenes.voxel) return voxelData;
    if (currentScene === scenes.mesh) return meshData;
    if (currentScene === scenes.smooth) return smoothData;
    return [];
  }

  animate();
</script>
