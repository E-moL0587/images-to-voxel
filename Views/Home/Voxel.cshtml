<div>
  <canvas id="mainCanvas"></canvas>
</div>

<div>
  <button onclick="showScene('voxel')">Voxel</button>
  <button onclick="showScene('mesh')">Mesh</button>
  <button onclick="showScene('smooth')">Smooth</button>
</div>

<script>
  const mainCanvas = document.querySelector('#mainCanvas');
  const renderer = new THREE.WebGLRenderer({ canvas: mainCanvas });
  const width = mainCanvas.clientWidth;
  const height = mainCanvas.clientHeight;
  renderer.setSize(width, height, false);

  const camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);
  camera.position.set(0, 0, 40);
  const controls = new THREE.OrbitControls(camera, renderer.domElement);

  const scenes = {
    voxel: new THREE.Scene(),
    mesh: new THREE.Scene(),
    smooth: new THREE.Scene()
  };

  function initScene(scene, data) {
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 7.5).normalize();
    scene.add(light);

    const boundingBox = new THREE.Box3();
    data.forEach(([x, y, z]) => boundingBox.expandByPoint(new THREE.Vector3(x, y, z)));
    const center = new THREE.Vector3();
    boundingBox.getCenter(center);

    if (scene === scenes.voxel) {
      data.forEach(([x, y, z]) => {
        const voxelMesh = new THREE.Mesh(
          new THREE.BoxGeometry(1, 1, 1),
          new THREE.MeshPhongMaterial({ color: 0xff00ff })
        );
        voxelMesh.position.set(-(x - center.x), -(y - center.y), -(z - center.z));
        scene.add(voxelMesh);
      });
    } else {
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      data.forEach(point => {
        vertices.push(-(point[0] - center.x), -(point[1] - center.y), -(point[2] - center.z));
      });
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.computeVertexNormals();
      const material = new THREE.MeshPhongMaterial({ color: 0xff00ff, side: THREE.DoubleSide });
      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);
    }
  }

  const voxelData = @Html.Raw(ViewData["VoxelData"]);
  const meshData = @Html.Raw(ViewData["MeshData"]);
  const smoothData = @Html.Raw(ViewData["SmoothData"]);

  initScene(scenes.voxel, voxelData);
  initScene(scenes.mesh, meshData);
  initScene(scenes.smooth, smoothData);

  let currentScene = scenes.voxel;

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(currentScene, camera);
  }

  function showScene(sceneName) {
    currentScene = scenes[sceneName];
  }

  animate();
</script>
